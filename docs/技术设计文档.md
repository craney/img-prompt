# ImagePrompt.He 技术设计文档

## 概述

本文档总结了 ImagePrompt.He 项目的技术设计逻辑，整合了产品迭代v1、v2和v3的技术方案和实现。

## 迭代版本历史与技术演进

### v1.0 - 认证系统基础架构重构
**核心变更**：
- 将认证系统从 Clerk 迁移至 NextAuth.js
- 重构数据库连接配置，解决连接字符串问题
- 实现 GitHub OAuth 和 Email Magic Link 认证方式

**技术实现**：

#### 1. 数据库连接重构
**文件**：`packages/db/index.ts`
```
// 修改前
import { createKysely } from "@vercel/postgres-kysely";
export const db = createKysely<DB>();

// 修改后
import { createClient } from "@vercel/postgres";
import { Kysely, PostgresDialect } from "kysely";

const client = createClient({
  connectionString: process.env.POSTGRES_URL,
});

export const db = new Kysely<DB>({
  dialect: new PostgresDialect({
    pool: client as any,
  }),
});
```

#### 2. NextAuth 配置实现
**新增文件**：`packages/auth/nextauth.ts`
```
import { NextAuthOptions } from "next-auth";
import { KyselyAdapter } from "@auth/kysely-adapter";
import GitHubProvider from "next-auth/providers/github";
import EmailProvider from "next-auth/providers/email";

export const authOptions: NextAuthOptions = {
  session: { strategy: "jwt" },
  pages: { signIn: "/login" },
  adapter: KyselyAdapter(db),
  providers: [
    GitHubProvider({
      clientId: env.GITHUB_CLIENT_ID,
      clientSecret: env.GITHUB_CLIENT_SECRET,
    }),
    EmailProvider({
      sendVerificationRequest: async ({ identifier, url }) => {
        // Resend 邮件发送逻辑
      },
    }),
  ],
  callbacks: {
    session({ token, session }) {
      // 会话回调处理
    },
    async jwt({ token, user }) {
      // JWT 令牌处理
    },
  },
};
```

#### 3. tRPC 认证上下文迁移
**文件**：`packages/api/src/trpc.ts`
```
// 修改前
import {auth, currentUser, getAuth} from "@clerk/nextjs/server";
type AuthObject = ReturnType<typeof getAuth>;

// 修改后
import { getToken } from "next-auth/jwt";

export const createTRPCContext = async (opts: {
  headers: Headers;
  req?: NextRequest;
}) => {
  const token = opts.req ? await getToken({ req: opts.req }) : null;
```

### v2.0 - 首页与品牌设计实现
**核心变更**：
- 复刻 https://imageprompt.org/ 首页设计
- 建立统一的品牌形象和视觉规范
- 实现响应式页面布局和国际化支持

**技术实现**：

#### 1. 组件架构设计
```
// apps/nextjs/src/app/[lang]/(marketing)/page.tsx
export default async function ImagePromptHomePage({
  params: { lang },
}: {
  params: { lang: Locale };
}) {
  const dict = await getDictionary(lang);
  
  return (
    <>
      {/* SEO Metadata */}
      <Metadata 
        title={dict.imageprompt.meta.title}
        description={dict.imageprompt.meta.description}
      />
      
      {/* Hero Section */}
      <ImagePromptHeroSection dict={dict.imageprompt.hero} />
      
      {/* Features Grid */}
      <ImagePromptFeaturesGrid 
        features={dict.imageprompt.features}
        interested={dict.imageprompt.interested}
      />
      
      {/* Tools Suite */}
      <ImagePromptToolsSuite dict={dict.imageprompt.tools} />
    </>
  );
}
```

#### 2. 核心组件实现

**HeroSection 组件**:
```
// apps/nextjs/src/components/imageprompt/hero-section.tsx
import { ColourfulText } from "@saasfly/ui/colorful-text";
import { Button } from "@saasfly/ui/button";

interface ImagePromptHeroSectionProps {
  dict: {
    title_prefix: string;
    title_highlight: string;
    subtitle: string;
    cta_primary: string;
    cta_secondary: string;
  };
}

export function ImagePromptHeroSection({ dict }: ImagePromptHeroSectionProps) {
  return (
    <section className="relative w-full py-12 md:py-24 lg:py-32 xl:py-48">
      <div className="container px-4 md:px-6">
        <div className="flex flex-col items-center space-y-4 text-center">
          <div className="space-y-2">
            <h1 className="text-3xl font-bold tracking-tighter sm:text-4xl md:text-5xl lg:text-6xl">
              {dict.title_prefix}{" "}
              <ColourfulText text={dict.title_highlight} />
            </h1>
            <p className="mx-auto max-w-[700px] text-gray-500 md:text-xl dark:text-gray-400">
              {dict.subtitle}
            </p>
          </div>
          <div className="space-x-4">
            <Button>{dict.cta_primary}</Button>
            <Button variant="outline">{dict.cta_secondary}</Button>
          </div>
        </div>
      </div>
    </section>
  );
}
```

#### 3. 国际化内容扩展
```
{
  "imageprompt": {
    "meta": {
      "title": "ImagePrompt.org - Create Better AI Art",
      "description": "Inspire ideas, Enhance image prompt, Create masterpieces"
    },
    "hero": {
      "title_prefix": "Create Better AI Art with",
      "title_highlight": "Image Prompt", 
      "subtitle": "Inspire ideas, Enhance image prompt, Create masterpieces",
      "cta_primary": "Try it now!",
      "cta_secondary": "Tutorials"
    },
    "features": [
      {
        "id": "image_to_prompt",
        "title": "Image to Prompt",
        "description": "Convert Image to Prompt to generate your own image",
        "icon": "Image"
      },
      {
        "id": "magic_enhance", 
        "title": "Magic Enhance",
        "description": "Transform simple text into detailed, descriptive image prompt",
        "icon": "Wand2"
      },
      {
        "id": "ai_describe",
        "title": "AI Describe Image",
        "description": "Let AI help you understand and analyze any image in detail", 
        "icon": "Eye"
      },
      {
        "id": "ai_generator",
        "title": "AI Image Generator", 
        "description": "Transform your image prompt into stunning visuals with AI-powered generation",
        "icon": "Sparkles"
      }
    ]
  }
}
```

### v3.0 - Image to Prompt 核心功能页面实现
**核心变更**：
- 实现Image to Prompt核心功能页面
- 支持多种上传方式
- 实现文件格式验证和大小限制
- 实现多语言支持

**技术实现**：

#### 1. 组件架构设计
```
apps/nextjs/src/app/[lang]/(tools)/
├── image-to-prompt/
│   ├── page.tsx                      # 主页面
│   ├── loading.tsx                   # 加载状态
│   ├── error.tsx                     # 错误处理
│   └── components/
│       ├── image-upload-section.tsx  # 上传区域
│       ├── image-preview-section.tsx # 预览区域
│       ├── feature-tabs.tsx          # 功能切换
│       ├── model-selection.tsx       # AI模型选择
│       ├── language-selector.tsx     # 语言选择器
│       └── prompt-generator.tsx      # 提示词生成组件
```

#### 2. 组件实现

**ImageToPromptPage 组件**:
```
// apps/nextjs/src/app/[lang]/(tools)/image-to-prompt/page.tsx
import { generateMetadata } from "@/app/[lang]/(tools)/image-to-prompt/metadata";
import { ImageToPromptClient } from "@/app/[lang]/(tools)/image-to-prompt/client";

export default ImageToPromptClient;

export { generateMetadata };

```

**ImageToPromptClient 组件**:
```
// apps/nextjs/src/app/[lang]/(tools)/image-to-prompt/client.tsx
import { useState } from "react";
import { Icons } from "@saasfly/ui/icons";
import { Button } from "@saasfly/ui/button";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@saasfly/ui/tabs";
import { Separator } from "@saasfly/ui/separator";

import { ImageToPromptHeader } from "@/app/[lang]/(tools)/image-to-prompt/components/image-to-prompt-header";
import { FeatureTabs } from "@/app/[lang]/(tools)/image-to-prompt/components/feature-tabs";
import { ImageUploadSection } from "@/app/[lang]/(tools)/image-to-prompt/components/image-upload-section";
import { ImagePreviewSection } from "@/app/[lang]/(tools)/image-to-prompt/components/image-preview-section";
import { ModelSelection } from "@/app/[lang]/(tools)/image-to-prompt/components/model-selection";
import { PromptGenerator } from "@/app/[lang]/(tools)/image-to-prompt/components/prompt-generator";

export function ImageToPromptClient() {
  const [file, setFile] = useState<File | null>(null);
  const [model, setModel] = useState<string>("general");
  const [language, setLanguage] = useState<string>("english");

  return (
    <div className="container mx-auto px-4 py-8">
      <ImageToPromptHeader />
      <FeatureTabs />
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
        <ImageUploadSection
          file={file}
          setFile={setFile}
          model={model}
          language={language}
        />
        <ImagePreviewSection file={file} />
      </div>
      <Separator className="my-4" />
      <ModelSelection model={model} setModel={setModel} />
      <PromptGenerator language={language} setLanguage={setLanguage} />
    </div>
  );
}

```


## 系统架构设计

### 整体架构
```
apps/nextjs/src/app/[lang]/(tools)/
├── image-to-prompt/
│   ├── page.tsx                      # 主页面
│   ├── loading.tsx                   # 加载状态
│   ├── error.tsx                     # 错误处理
│   └── components/
│       ├── image-upload-section.tsx  # 上传区域
│       ├── image-preview-section.tsx # 预览区域
│       ├── feature-tabs.tsx          # 功能切换
│       ├── model-selection.tsx       # AI模型选择
│       ├── language-selector.tsx     # 语言选择器
│       └── prompt-generator.tsx      # 提示词生成组件
```

### 组件架构
```
ImageToPromptPage (服务端组件) 
├── generateMetadata (SEO元数据)
└── ImageToPromptClient (客户端组件)
    ├── ImageToPromptHeader
    ├── FeatureTabs
    ├── 双栏布局
    │   ├── ImageUploadSection
    │   └── ImagePreviewSection
    ├── ModelSelection
    └── PromptGenerator
```

## 核心设计逻辑

### 1. 状态管理策略
- **上传状态**: `useState<File | null>(null)`
- **模型选择**: `useState<string>("general")`
- **语言选择**: `useState<string>("english")`
- **组件通信**: 通过props回调函数传递状态

### 2. 文件上传设计
支持多种上传方式：
- 拖拽上传
- 文件选择上传
- URL上传

验证机制：
- 文件格式验证 (PNG, JPG, WEBP)
- 文件大小限制 (5MB)
- URL有效性检查

### 3. UI/UX 设计规范

#### 色彩系统
- **主色调**: 紫色系 (#8B5CF6, #7C3AED, #6D28D9)
- **状态色彩**:
  - 激活状态: `border-purple-500 bg-purple-50`
  - 悬停状态: `hover:border-purple-400`
  - 文字色彩: `text-purple-600`

#### 布局规范
- **容器**: `container mx-auto px-4 py-8`
- **网格**: `grid grid-cols-1 lg:grid-cols-2 gap-8`
- **卡片间距**: `gap-4` (模型选择区域)
- **内边距**: `p-4, p-8` (根据组件大小)

#### 交互动画
- **过渡时间**: `transition-all duration-200`
- **悬停效果**: `hover:shadow-md`
- **拖拽反馈**: 边框颜色和背景色变化

### 4. 国际化设计
使用字典文件结构管理多语言内容：
```
{
  "imageToPrompt": {
    "meta": {
      "title": "Free Image to Prompt Generator - ImgPrompt.He",
      "description": "Convert images to detailed AI prompts. Upload your image and generate optimized prompts for Flux, Midjourney, Stable Diffusion and more."
    },
    "header": {
      "title": "Free Image to Prompt Generator",
      "subtitle": "Convert Image to Prompt to generate your own image"
    },
    "tabs": {
      "imageToPrompt": "Image to Prompt",
      "textToPrompt": "Text to Prompt"
    },
    "upload": {
      "dragText": "Upload a photo or drag and drop",
      "formatText": "PNG, JPG, or WEBP up to 5MB",
      "uploadButton": "Upload Image",
      "urlPlaceholder": "Input Image URL"
    },
    "preview": {
      "title": "Image Preview",
      "placeholder": "Your image will show here"
    },
    "models": {
      "general": {
        "title": "General Image Prompt",
        "description": "Natural language description of the image"
      },
      "flux": {
        "title": "Flux",
        "description": "Optimized for state-of-the-art Flux AI models, concise natural language"
      },
      "midjourney": {
        "title": "Midjourney", 
        "description": "Tailored for Midjourney generation with Midjourney parameters"
      },
      "stableDiffusion": {
        "title": "Stable Diffusion",
        "description": "Formatted for Stable Diffusion models"
      }
    },
    "generator": {
      "languageLabel": "Prompt Language:",
      "generateButton": "Generate Prompt",
      "languages": {
        "english": "English",
        "chinese": "中文",
        "japanese": "日本語",
        "korean": "한국어"
      }
    }
  }
}
```

### 5. 响应式设计
采用网格布局系统：
- 移动端: 单列布局
- 桌面端: 双列布局
- 平板端: 自适应布局

### 6. 性能优化策略
- **代码分割**: 组件级别分割
- **图标复用**: 扩展现有图标系统
- **样式复用**: 100%复用现有UI组件
- **类型安全**: 完整TypeScript支持

## 对外接口交互设计

### 1. Coze文件上传接口
- **接口地址**: `https://api.coze.cn/v1/files/upload`
- **请求方法**: POST
- **请求头**:
  ```
  Authorization: Bearer ${COZE_API_TOKEN}
  Content-Type: multipart/form-data
  ```
- **请求参数**:
  ```typescript
  interface CozeFileUploadRequest {
    file: File; // 上传的图片文件
  }
  ```
- **响应数据**:
  ```typescript
  interface CozeFileUploadResponse {
    code: number;        // 状态码，0表示成功
    msg: string;         // 状态消息
    data: {
      file_id: string;   // 文件ID，用于后续操作
      file_url: string;  // 文件访问URL
    };
  }
  ```
- **功能**: 上传图片文件到Coze平台并获取fileId
- **安全措施**: 访问令牌存储在环境变量中，不在前端暴露

### 2. Coze工作流调用接口
- **接口地址**: `https://api.coze.cn/v1/workflow/run`
- **请求方法**: POST
- **请求头**:
  ```
  Authorization: Bearer ${COZE_API_TOKEN}
  Content-Type: application/json
  Accept: application/json
  User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36
  ```
- **请求参数**:
  ```typescript
  interface CozeWorkflowRunRequest {
    workflow_id: "7548376142701658148"; // 固定的工作流ID
    parameters: {
      img: {
        file_id: string;     // 上传文件获得的fileId
      };
      promptType: string;    // 提示词类型 (Normal, Flux, Midjourney, StableDiffusion)
      lang: string;          // 提示词语言 (english, chinese, japanese, korean)
    };
  }
  ```
- **响应数据**:
  ```typescript
  interface CozeWorkflowRunResponse {
    code: number;           // 状态码，0表示成功
    msg: string;            // 状态消息
    data: string;           // JSON字符串，需要进一步解析
    debug_url?: string;     // 调试URL
  }
  
  // data字段解析后的结构示例
  interface CozeWorkflowData {
    prompt: string;         // 生成的提示词结果
    // 其他可能的字段
  }
  ```
- **功能**: 根据用户选择的模型和上传的fileId生成提示词
- **参数映射**:
  - General Image Prompt → Normal
  - Flux → Flux
  - Midjourney → Midjourney
  - Stable Diffusion → StableDiffusion
  - 语言参数映射：前端语言值直接传递给Coze接口的lang参数

### v3.1 - 首页按钮跳转功能实现

#### 📝 迭代背景

为提升用户体验和功能导航，需要为首页的两个核心按钮（"立即试用"和"图片转提示词"）添加跳转功能，让用户能够直接从首页访问 Image to Prompt 工具页面。

#### 🎯 迭代目标

##### 技术目标
- 使用 Next.js Link 组件实现声明式导航
- 保持国际化路由支持
- 确保SEO友好性和性能优化
- 维持现有设计风格和交互体验

#### 🔧 技术实现方案

##### 1. 技术选型分析

**方案选择**: Next.js Link 组件声明式导航

**选择理由**:
- ✅ SEO 友好，有助于页面索引
- ✅ 性能更好，支持预加载功能
- ✅ 符合 Next.js 最佳实践
- ✅ 代码简洁，维护容易

**对比方案**: useRouter + onClick 事件处理
- ❌ SEO 不友好
- ❌ 无预加载功能
- ❌ 必须使用客户端渲染

##### 2. 组件架构设计

**涉及文件**:
```
apps/nextjs/src/app/[lang]/(marketing)/page.tsx          # 主页面调用
components/imageprompt/hero-section.tsx                  # Hero组件实现
```

**数据流设计**:
```
Marketing Page (lang) → Hero Section (dict, lang) → Link Components (/{lang}/image-to-prompt)
```

##### 3. 核心实现设计

**主页面调用修改**:
```typescript
// apps/nextjs/src/app/[lang]/(marketing)/page.tsx
export default async function ImagePromptHomePage({
  params: { lang },
}: {
  params: {
    lang: Locale;
  };
}) {
  const dict = await getDictionary(lang);

  return (
    <>
      {/* Hero Section - 传递 lang 参数 */}
      <ImagePromptHeroSection 
        dict={dict.imageprompt.hero} 
        lang={lang} 
      />
      
      {/* ... 其他组件 ... */}
    </>
  );
}
```

**Hero 组件接口更新**:
```typescript
interface ImagePromptHeroSectionProps {
  dict: {
    title_prefix: string;
    title_highlight: string;
    title_suffix: string;
    subtitle: string;
    cta_primary: string;
    cta_secondary: string;
  };
  lang: string; // 新增语言参数
}
```

**Link 组件实现**:
```typescript
"use client";

import Link from "next/link";
import { ColourfulText } from "@saasfly/ui/colorful-text";
import { Button } from "@saasfly/ui/button";

export function ImagePromptHeroSection({ dict, lang }: ImagePromptHeroSectionProps) {
  const targetPath = `/${lang}/image-to-prompt`;

  return (
    <section className="container pt-20 pb-16">
      {/* ... 其他内容 ... */}
      
      {/* CTA 按钮组 */}
      <div className="flex flex-col sm:flex-row gap-4 mb-16">
        <Link href={targetPath} prefetch={true}>
          <Button 
            size="lg" 
            className="bg-purple-600 hover:bg-purple-700 text-white px-8 py-3 text-lg rounded-full w-full"
          >
            {dict.cta_primary}
          </Button>
        </Link>
        
        <Link href={targetPath} prefetch={true}>
          <Button 
            size="lg" 
            variant="outline" 
            className="border-purple-200 text-purple-600 hover:bg-purple-50 px-8 py-3 text-lg rounded-full w-full"
          >
            {dict.cta_secondary}
          </Button>
        </Link>
      </div>
    </section>
  );
}
```

##### 4. 国际化路由设计

**路由结构**:
```
/en/image-to-prompt    # 英文版本
/zh/image-to-prompt    # 中文版本  
/ja/image-to-prompt    # 日文版本
/ko/image-to-prompt    # 韩文版本
```

**参数传递机制**:
- 从主页面传递 `lang` 参数
- 在 Hero 组件中构建完整路径
- 确保与现有国际化结构一致

##### 5. 性能优化策略

**预加载机制**:
- 使用 `prefetch={true}` 启用预加载
- 鼠标悬停时自动加载目标页面
- 提升页面切换体验

**SEO 优化**:
- 使用声明式 Link 组件
- 确保搜索引擎可以识别链接
- 正确传递页面权重

##### 6. 错误处理机制

**路由验证**:
- 确保 `lang` 参数有效性
- 处理无效语言代码
- 提供合适的降级方案

**加载状态**:
- 预加载时显示加载状态
- 处理页面加载失败情况
- 提供用户友好的错误提示

#### 🎨 UI/UX 设计规范

##### 视觉一致性
- 保持按钮现有样式和布局
- 维持紫色主题色彩系统
- 确保响应式设计适配

##### 交互体验
- 鼠标悬停效果保持不变
- 点击反馈保持一致
- 页面切换动画流畅

#### 📊 技术性能指标

##### 性能要求
- 页面预加载：鼠标悬停时预加载目标页面
- 切换速度：< 1秒
- 内存使用：合理的预加载策略

##### 兼容性要求
- 支持所有现代浏览器
- 移动端适配良好
- SEO友好性

#### 🧪 测试策略

##### 功能测试
- [ ] 按钮点击跳转功能正常
- [ ] 国际化路由正确传递
- [ ] 页面加载和切换流畅
- [ ] 按钮样式和交互效果保持一致

##### 兼容性测试
- [ ] 多语言版本测试
- [ ] 移动端适配测试
- [ ] 不同浏览器兼容性测试

##### 性能测试
- [ ] 页面预加载功能验证
- [ ] 页面切换速度测试
- [ ] 内存使用监控

#### 🔧 实施计划

##### 开发步骤
1. 修改主页面调用，传递 `lang` 参数
2. 更新 Hero 组件接口和实现
3. 使用 Link 组件替换静态按钮
4. 添加预加载功能
5. 测试多语言版本兼容性

##### 测试步骤
1. 本地开发环境测试
2. 多语言版本验证
3. 移动端适配测试
4. 性能和SEO验证
5. 部署环境验证

#### 🎯 成功验收标准

##### 功能验收
- [ ] 两个按钮都能正确跳转到 Image to Prompt 页面
- [ ] 跳转路径包含正确的语言参数
- [ ] 页面切换过程流畅无卡顿
- [ ] 按钮样式和交互效果保持不变

##### 性能验收
- [ ] 页面切换时间 < 1秒
- [ ] 预加载功能正常工作
- [ ] 无内存泄漏问题
- [ ] 移动端体验良好

##### SEO验收
- [ ] 链接可被搜索引擎识别
- [ ] 页面权重正确传递
- [ ] 路由结构符合SEO最佳实践

### 3. 内部API路由设计
```
apps/nextjs/src/app/api/
├── coze/
│   ├── upload/
│   │   └── route.ts     # Coze文件上传API路由
│   └── workflow/
│       └── route.ts     # Coze工作流调用API路由
```

#### 内部Coze文件上传API
- **路由路径**: `/api/coze/upload`
- **请求方法**: POST
- **请求参数**:
  ```typescript
  interface InternalCozeUploadRequest {
    image: File; // 前端传递的图片文件
  }
  ```
- **响应数据**:
  ```typescript
  interface InternalCozeUploadResponse {
    success: boolean;     // 上传是否成功
    fileId?: string;      // 文件ID (成功时)
    errorMessage?: string;// 错误信息 (失败时)
  }
  ```

#### 内部Coze工作流调用API
- **路由路径**: `/api/coze/workflow`
- **请求方法**: POST
- **请求参数**:
  ```typescript
  interface InternalCozeWorkflowRequest {
    fileId: string;         // 文件ID
    promptType: string;     // 提示词类型
  }
  ```
- **响应数据**:
  ```typescript
  interface InternalCozeWorkflowResponse {
    success: boolean;       // 调用是否成功
    prompt?: string;        // 生成的提示词 (成功时)
    debugUrl?: string;      // 调试URL (成功时)
    errorMessage?: string;  // 错误信息 (失败时)
  }
  ```

## 遇到的问题及解决方案

### 1. 页面访问权限问题 (v3.0.1)
**问题描述**: Image to Prompt页面默认需要登录才能访问，影响用户体验。

**解决方案**: 
- 修改 `apps/nextjs/src/utils/nextauth.ts` 文件
- 将 `/image-to-prompt` 路径添加到公共路由列表中
- 保持与其他公共页面（如pricing、docs）一致的访问方式

**安全考虑**:
- 仅开放了工具使用页面，不涉及用户数据或敏感功能
- 实际的AI服务调用可以根据需要添加限流或其他保护措施

### 2. 字典访问路径错误 (v3.0.2)
**问题描述**: 页面字典访问路径错误，导致页面无法正常显示内容。

**解决方案**:
- 修复 `apps/nextjs/src/app/[lang]/(tools)/image-to-prompt/page.tsx` 中的字典访问路径
- 将 `dict.imageToPrompt.meta.title` 修改为 `dict.imageprompt.imageToPrompt.meta.title`

### 3. Icons组件导入方式错误 (v3.0.2)
**问题描述**: Icons组件导入方式不正确，导致图标无法正常显示。

**解决方案**:
- 将 `import { Icons } from "@saasfly/ui/icons"` 修改为 `import * as Icons from "@saasfly/ui/icons"`
- 修复了多个相关组件文件中的导入方式

### 4. Coze API地址确认 (v3.0.4)
**问题描述**: 用户反馈Coze API域名可能不正确。

**解决方案**:
- 确认Coze API的正确域名为 `api.coze.cn`
- 检查代码中使用的API地址已经是正确的 `https://api.coze.cn/v1/files/upload`
- 无需进行代码修改

### 5. 工作流调用集成 (v3.0.5)
**问题描述**: 需要集成Coze工作流调用功能，根据用户选择的模型生成提示词。

**解决方案**:
- 创建后端API路由处理Coze工作流调用
- 在前端组件中调用新的后端API
- 根据用户选择的模型传递对应的promptType参数
- 安全地管理Coze访问令牌，存储在环境变量中

## API 设计

### 环境变量需求
```bash
# AI服务配置
NEXT_PUBLIC_AI_SERVICE_URL=
AI_SERVICE_API_KEY=

# 文件存储配置
NEXT_PUBLIC_UPLOAD_BUCKET=
UPLOAD_SERVICE_KEY=

# 图片处理配置
IMAGE_RESIZE_QUALITY=80
IMAGE_MAX_SIZE=5242880  # 5MB

# Coze平台配置
COZE_API_TOKEN=your_coze_api_token
COZE_WORKFLOW_ID=7548376142701658148
```

### 后端服务需求
1. **文件上传API**
   - 文件存储服务
   - 图片格式转换
   - 文件安全检查

2. **图片分析API**
   - AI图片识别服务
   - 多模型支持
   - 提示词生成

## 安全设计

### 访问控制
- 页面设置为公共访问，无需登录即可使用
- 保持与其他公共页面（如pricing、docs）一致的访问方式

### 数据安全
- 文件格式验证
- 文件大小限制
- 图片安全检查
- API令牌安全存储在环境变量中

### API路由安全
- Coze相关API路由不进行登录验证
- 访问令牌存储在环境变量中，不在前端暴露
- 错误处理和日志记录

## 部署考虑

### CDN配置
- 静态资源缓存
- 图片优化配置
- 上传文件的临时存储

## 测试策略

### 单元测试
- 文件上传组件测试
- 图片预览组件测试
- 模型选择组件测试
- 表单验证测试

### 集成测试
- 端到端上传流程测试
- AI服务调用测试
- 多语言切换测试
- 响应式布局测试

### 性能测试
- 文件上传性能测试
- 大图片处理测试
- 并发请求测试
- 内存泄漏测试

### v4.0 - Google OAuth集成实现

#### 📝 迭代背景

在v3.0的基础上，为ImagePrompt.He平台集成Google OAuth 2.0认证功能。该功能将与现有的GitHub OAuth和邮箱认证系统并存，为用户提供更多登录选择，提升用户体验和注册转化率。

#### 🎯 技术实现目标

##### 核心技术目标
- 基于NextAuth.js框架集成Google OAuth 2.0 Provider
- 保持与现有认证系统的完全兼容性
- 实现多语言界面支持和响应式设计
- 确保OAuth流程的安全性和稳定性

##### 架构设计目标
- 最小化代码修改，复用现有组件和架构
- 保持数据库结构的稳定性
- 实现条件加载机制，只在配置有效时启用Google登录
- 维护现有的国际化支持体系

#### 🔧 技术架构设计

##### 整体架构
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   前端应用       │    │   NextAuth.js   │    │   Google OAuth  │
│  (Next.js 14)    │◄──►│   认证中间件     │◄──►│     API        │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                                │
                                ▼
                       ┌─────────────────┐
                       │   PostgreSQL    │
                       │    数据库       │
                       └─────────────────┘
```

##### 技术栈
- **前端**: Next.js 14 (App Router)
- **认证**: NextAuth.js v4
- **OAuth**: Google OAuth 2.0
- **数据库**: PostgreSQL + Kysely
- **类型安全**: TypeScript
- **UI组件**: @saasfly/ui
- **国际化**: 自定义i18n解决方案

#### 🔧 核心实现

##### 1. 环境配置实现

###### 环境变量配置 (apps/nextjs/src/env.mjs)
```typescript
export const env = createEnv({
  server: {
    // 现有配置...
    GOOGLE_CLIENT_ID: z.string().min(1),
    GOOGLE_CLIENT_SECRET: z.string().min(1),
  },
  runtimeEnv: {
    // 现有配置...
    GOOGLE_CLIENT_ID: process.env.GOOGLE_CLIENT_ID,
    GOOGLE_CLIENT_SECRET: process.env.GOOGLE_CLIENT_SECRET,
  },
});
```

###### 环境变量模板 (.env.example)
```bash
# Google OAuth配置
GOOGLE_CLIENT_ID='your_google_client_id'
GOOGLE_CLIENT_SECRET='your_google_client_secret'
```

##### 2. NextAuth配置实现

###### 认证配置文件更新 (packages/auth/nextauth.ts)
```typescript
import { getServerSession, NextAuthOptions, User } from "next-auth";
import { KyselyAdapter } from "@auth/kysely-adapter";
import GitHubProvider from "next-auth/providers/github";
import GoogleProvider from "next-auth/providers/google";
import EmailProvider from "next-auth/providers/email";

export const authOptions: NextAuthOptions = {
  session: {
    strategy: "jwt",
  },
  pages: {
    signIn: "/login",
  },
  adapter: KyselyAdapter(db) as any,

  providers: [
    // GitHub Provider (现有)
    ...(env.GITHUB_CLIENT_ID && env.GITHUB_CLIENT_SECRET
      ? [
          GitHubProvider({
            clientId: getEnv("GITHUB_CLIENT_ID", env.GITHUB_CLIENT_ID),
            clientSecret: getEnv("GITHUB_CLIENT_SECRET", env.GITHUB_CLIENT_SECRET),
            httpOptions: { timeout: 15000 },
          }),
        ]
      : []),

    // Google Provider (新增)
    ...(env.GOOGLE_CLIENT_ID && env.GOOGLE_CLIENT_SECRET
      ? [
          GoogleProvider({
            clientId: getEnv("GOOGLE_CLIENT_ID", env.GOOGLE_CLIENT_ID),
            clientSecret: getEnv("GOOGLE_CLIENT_SECRET", env.GOOGLE_CLIENT_SECRET),
            httpOptions: { timeout: 15000 },
          }),
        ]
      : []),

    // Email Provider (现有)
    ...(env.RESEND_FROM && env.RESEND_API_KEY
      ? [
          EmailProvider({
            // 现有邮件配置...
          }),
        ]
      : []),
  ],

  // 保持现有的callbacks配置
  callbacks: {
    session({ token, session }) {
      if (token && session.user) {
        session.user.id = token.id;
        session.user.name = token.name ?? undefined;
        session.user.email = token.email ?? undefined;
        session.user.image = token.picture ?? undefined;
        session.user.isAdmin = token.isAdmin || false;
      }
      return session;
    },
    async jwt({ token, user }) {
      const email = token?.email ?? "";
      const dbUser = email
        ? await db
            .selectFrom("User")
            .where("email", "=", email)
            .selectAll()
            .executeTakeFirst()
        : null;

      if (!dbUser) {
        if (user) {
          token.id = user.id as UserId;
          token.isAdmin = false;
        }
        return token;
      }

      let isAdmin = false;
      if (env.ADMIN_EMAIL) {
        const adminEmails = getEnv("ADMIN_EMAIL", env.ADMIN_EMAIL).split(",");
        if (email) {
          isAdmin = adminEmails.includes(email);
        }
      }

      return {
        id: dbUser.id,
        name: dbUser.name,
        email: dbUser.email,
        picture: dbUser.image,
        isAdmin: isAdmin,
      };
    },
  },
};
```

##### 3. 前端UI组件实现

###### 用户认证表单更新 (apps/nextjs/src/components/user-auth-form.tsx)
```typescript
"use client";

import * as React from "react";
import { useSearchParams } from "next/navigation";
import { signIn } from "next-auth/react";
import { useForm } from "react-hook-form";
import * as z from "zod";

import { cn } from "@saasfly/ui";
import { buttonVariants } from "@saasfly/ui/button";
import * as Icons from "@saasfly/ui/icons";

export function UserAuthForm({
  className,
  lang,
  dict,
  disabled,
  ...props
}: UserAuthFormProps) {
  const [isLoading, setIsLoading] = React.useState<boolean>(false);
  const [isGitHubLoading, setIsGitHubLoading] = React.useState<boolean>(false);
  const [isGoogleLoading, setIsGoogleLoading] = React.useState<boolean>(false);
  const searchParams = useSearchParams();

  async function onSubmit(data: FormData) {
    // 现有的邮箱登录逻辑...
  }

  return (
    <div className={cn("grid gap-6", className)} {...props}>
      {/* 邮箱登录表单 (现有) */}
      <form onSubmit={handleSubmit(onSubmit)}>
        {/* 邮箱登录逻辑 */}
      </form>

      <div className="relative">
        <div className="absolute inset-0 flex items-center">
          <span className="w-full border-t" />
        </div>
        <div className="relative flex justify-center text-xs uppercase">
          <span className="bg-background px-2 text-muted-foreground">
            {dict.signin_others}
          </span>
        </div>
      </div>

      {/* GitHub登录按钮 (现有) */}
      <button
        type="button"
        className={cn(buttonVariants({ variant: "outline" }))}
        onClick={() => {
          setIsGitHubLoading(true);
          signIn("github").catch((error) => {
            console.error("GitHub signIn error:", error);
          });
        }}
        disabled={isLoading || isGitHubLoading || isGoogleLoading}
      >
        {isGitHubLoading ? (
          <Icons.Spinner className="mr-2 h-4 w-4 animate-spin" />
        ) : (
          <Icons.GitHub className="mr-2 h-4 w-4" />
        )}{" "}
        {dict.signin_github}
      </button>

      {/* Google登录按钮 (新增) */}
      <button
        type="button"
        className={cn(buttonVariants({ variant: "outline" }))}
        onClick={() => {
          setIsGoogleLoading(true);
          signIn("google").catch((error) => {
            console.error("Google signIn error:", error);
          });
        }}
        disabled={isLoading || isGitHubLoading || isGoogleLoading}
      >
        {isGoogleLoading ? (
          <Icons.Spinner className="mr-2 h-4 w-4 animate-spin" />
        ) : (
          <Icons.Google className="mr-2 h-4 w-4" />
        )}{" "}
        {dict.signin_google}
      </button>
    </div>
  );
}
```

##### 4. 国际化配置实现

###### 多语言文件更新
```json
// apps/nextjs/src/config/dictionaries/en.json
{
  "login": {
    "signin_email": "Log in with Email",
    "signin_google": "Sign in with Google",
    "signin_github": "Sign in with Github",
    "signin_others": "Or continue with"
  }
}

// apps/nextjs/src/config/dictionaries/zh.json
{
  "login": {
    "signin_email": "用电子邮件登录",
    "signin_google": "使用 Google 登录",
    "signin_github": "使用 Github 登录",
    "signin_others": "或者继续使用"
  }
}

// apps/nextjs/src/config/dictionaries/ja.json
{
  "login": {
    "signin_email": "メールでログイン",
    "signin_google": "Googleでログイン",
    "signin_github": "Githubでログイン",
    "signin_others": "または続ける"
  }
}

// apps/nextjs/src/config/dictionaries/ko.json
{
  "login": {
    "signin_email": "이메일로 로그인",
    "signin_google": "Google로 로그인",
    "signin_github": "Github로 로그イン",
    "signin_others": "또는 다음으로 계속"
  }
}
```

#### 🗄️ 数据库设计

##### 现有表结构（无需修改）
```sql
-- User表 - 支持OAuth用户
CREATE TABLE "User" (
    "id" TEXT PRIMARY KEY,
    "name" TEXT,
    "email" TEXT NOT NULL UNIQUE,
    "emailVerified" TIMESTAMP,
    "image" TEXT,
    "createdAt" TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Account表 - 存储OAuth凭据
CREATE TABLE "Account" (
    "id" TEXT PRIMARY KEY,
    "userId" TEXT NOT NULL REFERENCES "User"("id") ON DELETE CASCADE,
    "type" TEXT NOT NULL,
    "provider" TEXT NOT NULL,
    "providerAccountId" TEXT NOT NULL,
    "refresh_token" TEXT,
    "access_token" TEXT,
    "expires_at" INTEGER,
    "token_type" TEXT,
    "scope" TEXT,
    "id_token" TEXT,
    "session_state" TEXT,
    "createdAt" TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Session表 - 管理会话信息
CREATE TABLE "Session" (
    "id" TEXT PRIMARY KEY,
    "sessionToken" TEXT NOT NULL UNIQUE,
    "userId" TEXT NOT NULL REFERENCES "User"("id") ON DELETE CASCADE,
    "expires" TIMESTAMP NOT NULL,
    "createdAt" TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);
```

##### 数据映射逻辑
- Google OAuth用户数据自动映射到User表
- Account表存储Google OAuth凭据（provider = "google"）
- Session表管理用户会话信息
- 同一邮箱的不同Provider账户自动关联

#### 🔒 安全实现

##### OAuth安全配置
```typescript
GoogleProvider({
  clientId: getEnv("GOOGLE_CLIENT_ID", env.GOOGLE_CLIENT_ID),
  clientSecret: getEnv("GOOGLE_CLIENT_SECRET", env.GOOGLE_CLIENT_SECRET),
  httpOptions: { timeout: 15000 },
  // 可选：添加额外的安全配置
  authorization: {
    params: {
      prompt: "consent",
      access_type: "offline",
      response_type: "code",
    },
  },
}),
```

##### 会话管理安全
- 使用JWT session策略
- 安全的token生成和验证机制
- 适当的过期时间设置
- 服务端session验证

##### 数据验证和安全
- 环境变量验证使用Zod schema
- 输入数据验证和清理
- 防止OAuth注入攻击
- CSRF保护
- HTTPS传输加密

#### 🌐 国际化实现

##### 多语言支持架构
```
apps/nextjs/src/config/dictionaries/
├── en.json    # 英文
├── zh.json    # 中文简体
├── ja.json    # 日文
└── ko.json    # 韩文
```

##### 语言切换机制
- 基于URL路径的语言识别 (`/[lang]/`)
- 自动检测浏览器语言偏好
- 用户语言偏好存储
- 回退到默认语言机制

##### 字典文件结构
```typescript
interface LoginDictionary {
  signin_email: string;
  signin_google: string;
  signin_github: string;
  signin_others: string;
}

interface Dictionary {
  login: LoginDictionary;
  // 其他字典内容...
}
```

#### 🚨 错误处理实现

##### 前端错误处理
```typescript
const handleGoogleSignIn = async () => {
  setIsGoogleLoading(true);
  try {
    const result = await signIn("google", {
      callbackUrl: searchParams?.get("from") ?? `/${lang}/dashboard`,
      redirect: false
    });

    if (!result?.ok) {
      throw new Error("Google登录失败");
    }
  } catch (error) {
    console.error("Google signIn error:", error);
    toast({
      title: "登录失败",
      description: "Google登录出现错误，请稍后重试。",
      variant: "destructive",
    });
  } finally {
    setIsGoogleLoading(false);
  }
};
```

##### 后端错误处理
```typescript
// 在NextAuth配置中添加错误处理
callbacks: {
  async signIn({ user, account, profile, email, credentials }) {
    try {
      // 验证用户信息
      if (!profile?.email) {
        throw new Error("无法获取用户邮箱");
      }

      // 检查邮箱域名限制（如果需要）
      // if (!profile.email.endsWith('@allowed-domain.com')) {
      //   throw new Error("邮箱域名不被允许");
      // }

      return true;
    } catch (error) {
      console.error("Sign in error:", error);
      return false;
    }
  },
},
```

#### 📊 性能优化实现

##### 前端优化
- 按需加载OAuth组件
- 使用React.memo优化渲染性能
- 防抖处理用户交互
- 图片懒加载和缓存
- 预加载目标页面

##### 后端优化
- 数据库查询优化
- 会话缓存策略
- 异步处理非关键路径
- 连接池管理
- 错误重试机制

##### 网络优化
- CDN加速静态资源
- HTTP/2多路复用
- 资源压缩和合并
- 缓存策略优化
- 预连接Google OAuth端点

#### 🧪 测试实现

##### 单元测试
```typescript
// 测试Google Provider配置
describe('Google OAuth Configuration', () => {
  it('should configure GoogleProvider with correct credentials', () => {
    const googleProvider = GoogleProvider({
      clientId: 'test-client-id',
      clientSecret: 'test-client-secret',
    });

    expect(googleProvider).toBeDefined();
    expect(googleProvider.id).toBe('google');
  });
});

// 测试登录组件
describe('UserAuthForm', () => {
  it('should render Google login button', () => {
    const { getByText } = render(<UserAuthForm />);
    expect(getByText('Sign in with Google')).toBeInTheDocument();
  });
});
```

##### 集成测试
- 完整的OAuth流程测试
- 用户注册和登录流程测试
- 多语言切换测试
- 响应式设计测试
- 错误处理机制测试

##### E2E测试
```typescript
// Playwright E2E测试
test('Google login flow', async ({ page }) => {
  await page.goto('/login');
  await page.click('button:has-text("Sign in with Google")');

  // 模拟Google OAuth回调（在测试环境中）
  await page.waitForURL('/dashboard');
  expect(page.url()).toContain('/dashboard');
});
```

#### 📈 监控和日志实现

##### 性能监控
```typescript
// 登录性能监控
const signInWithMonitoring = async (provider: string) => {
  const startTime = Date.now();
  try {
    const result = await signIn(provider);
    const duration = Date.now() - startTime;

    // 上报性能指标
    if (window.performance) {
      window.performance.mark(`${provider}_signin_end`);
      window.performance.measure(`${provider}_signin`, `${provider}_signin_start`, `${provider}_signin_end`);
    }

    return result;
  } catch (error) {
    // 错误监控
    console.error(`${provider} sign in error:`, error);
    throw error;
  }
};
```

##### 错误监控
- Sentry错误跟踪
- 控制台错误日志
- 用户反馈收集
- 系统健康检查

##### 业务监控
- 登录成功率统计
- 用户注册转化率
- 各登录方式使用比例
- 用户行为分析

#### 🚀 部署配置

##### 环境变量设置
```bash
# 生产环境配置
NEXTAUTH_URL=https://your-domain.com
NEXTAUTH_SECRET=your-secret-key
GOOGLE_CLIENT_ID=your-google-client-id
GOOGLE_CLIENT_SECRET=your-google-client-secret
```

##### Google Cloud Console配置
1. 创建新项目或选择现有项目
2. 启用Google+ API
3. 配置OAuth 2.0凭据
4. 设置重定向URI: `https://your-domain.com/api/auth/callback/google`
5. 配置同意屏幕

##### Vercel部署配置
```json
// vercel.json
{
  "build": {
    "env": {
      "NEXTAUTH_URL": "https://your-domain.com",
      "GOOGLE_CLIENT_ID": "@google_client_id",
      "GOOGLE_CLIENT_SECRET": "@google_client_secret"
    }
  }
}
```

#### 🔧 运维和维护

##### 日常维护
- 定期更新依赖包版本
- 监控API使用配额
- 备份关键配置文件
- 性能指标监控
- 安全漏洞扫描

##### 故障处理
- OAuth服务不可用的降级方案
- 用户会话异常的处理机制
- 数据库连接失败的恢复策略
- 网络异常的重试机制

##### 版本管理
- 语义化版本控制
- 变更日志维护
- 向后兼容性保证
- 渐进式功能发布

#### 🎯 成功验收标准

##### 功能验收
- [ ] Google登录按钮在登录页面正常显示
- [ ] 点击Google按钮能正常跳转到OAuth授权页面
- [ ] 用户授权后能正确创建账户或登录现有账户
- [ ] 用户头像和基本信息能正确同步
- [ ] 与现有登录方式能正常切换使用
- [ ] 多语言界面显示正确

##### 性能验收
- [ ] Google登录成功率 > 99%
- [ ] 登录流程响应时间 < 3秒
- [ ] 系统在并发登录情况下稳定运行
- [ ] 错误恢复机制工作正常
- [ ] 页面加载性能达标

##### 安全验收
- [ ] OAuth流程符合OAuth 2.0安全标准
- [ ] 用户数据得到适当保护
- [ ] 没有发现安全漏洞或风险
- [ ] 符合数据隐私保护要求
- [ ] 环境变量和敏感信息安全

##### 兼容性验收
- [ ] 支持所有现代浏览器
- [ ] 移动端设备适配良好
- [ ] 多语言环境正常工作
- [ ] 不同屏幕分辨率适配正常
- [ ] 与现有系统完全兼容